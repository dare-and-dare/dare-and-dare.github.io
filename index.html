<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×—×•×‘×” ×•×—×•×‘×”</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Assistant:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="images/heart_logo.png">

    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Assistant', sans-serif;
            background: linear-gradient(135deg, #4a0e2e 0%, #1d1d4e 100%);
            position: relative;
        }

        #background-logo {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-image: url('/images/logo.png');
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0.05;
            z-index: -2;
        }

        #hearts-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -1;
        }

        .heart {
            position: absolute;
            bottom: -50px;
            font-size: 2rem;
            color: rgba(255, 255, 255, 0.2);
            animation: floatUp linear infinite;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) translateX(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-110vh) translateX(50px);
                opacity: 0;
            }
        }

        .card {
            width: 22vw;
            height: 31vw;
            max-width: 120px;
            max-height: 170px;
            min-width: 80px;
            min-height: 114px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            user-select: none;
            position: relative;
            perspective: 1000px;
            flex-shrink: 0;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .card.is-flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            padding: 8px;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            text-align: center;
        }

        .card-front {
            background-color: #fff0f5;
            color: #333;
            border: 3px solid;
            align-items: center;
            justify-content: center;
            transform: rotateY(180deg);
        }

            .card-front .card-type-header {
                font-weight: 700;
                font-size: 0.75rem;
                padding-bottom: 4px;
                margin-bottom: 4px;
                width: 100%;
                border-bottom: 1px solid;
            }

        .card-type-×©××œ×” {
            border-color: #3b82f6;
        }

            .card-type-×©××œ×” .card-type-header {
                color: #3b82f6;
                border-color: #bfdbfe;
            }

        .card-type-××©×™××” {
            border-color: #ec4899;
        }

            .card-type-××©×™××” .card-type-header {
                color: #ec4899;
                border-color: #fbcfe8;
            }

        .card-type-×¡×•×“ {
            border-color: #8b5cf6;
        }

            .card-type-×¡×•×“ .card-type-header {
                color: #8b5cf6;
                border-color: #ddd6fe;
            }

        .card-front p {
            font-size: clamp(0.7rem, 2.2vw, 0.9rem);
            word-wrap: break-word;
            line-height: 1.3;
        }

        .card-back {
            background-image: url('/images/logo.png');
            background-size: cover;
            background-position: center;
            border: 2px solid #fce7f3;
        }

        body.is-my-turn #player-hand .card:hover {
            transform: translateY(-20px) scale(1.05);
            z-index: 100;
        }

        #deck {
            position: relative;
            width: 22vw;
            height: 31vw;
            max-width: 120px;
            max-height: 170px;
            min-width: 80px;
            min-height: 114px;
        }

            #deck .card {
                position: absolute;
                top: 0;
                left: 0;
            }

                #deck .card:nth-child(2) {
                    transform: translate(2px, 2px);
                }

                #deck .card:nth-child(3) {
                    transform: translate(4px, 4px);
                }

                #deck .card:nth-child(4) {
                    transform: translate(6px, 6px);
                }

        #play-area {
            position: relative;
        }

        /* === Added rule for mobile phones === */
        @media (max-width: 639px) { /* This targets screens smaller than 640px (Tailwind's 'sm' breakpoint) */
            #play-area {
                flex-grow: 0; /* Prevents the area from growing aggressively */
                height: 30vh; /* Sets a specific height relative to the screen height */
            }
        }
        /* ==================================== */

        #play-area .card {
            position: absolute;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #be185d;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #toast-notification {
            position: fixed;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 9999px;
            color: white;
            font-size: 1rem;
            z-index: 999;
            transition: all 0.5s ease-in-out;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            text-align: center;
        }

            #toast-notification.show {
                bottom: 20px;
            }

        .toast-info {
            background-color: #3b82f6;
        }

        .toast-warning {
            background-color: #f59e0b;
        }

        .toast-success {
            background-color: #22c55e;
        }

        #opponent-hand {
            position: relative;
        }

            #opponent-hand .card {
                position: absolute;
                left: 50%;
                bottom: 0;
                transform-origin: bottom center;
            }
    </style>
</head>
<body class="text-white flex flex-col items-center justify-center min-h-screen p-2 sm:p-4">

    <div id="background-logo"></div>
    <div id="hearts-container"></div>
    <div id="toast-notification"></div>

    <div id="rules-modal" class="hidden fixed inset-0 z-30 flex items-center justify-center bg-black bg-opacity-70 backdrop-blur-sm p-4">
        <div class="bg-gray-800 text-white p-8 rounded-2xl shadow-xl max-w-lg w-full border border-pink-500 relative">
            <h2 class="text-3xl font-bold text-pink-300 mb-4 text-center">××™×š ××©×—×§×™×?</h2>
            <div class="space-y-4 text-gray-300 max-h-[70vh] overflow-y-auto pr-2">
                <p><strong>××˜×¨×ª ×”××©×—×§:</strong> ×œ×”×ª×—×‘×¨, ×œ×™×”× ×•×ª ×•×œ×’×œ×•×ª ×“×‘×¨×™× ×—×“×©×™× ××—×“ ×¢×œ ×”×©× ×™×™×” ×“×¨×š ×©××œ×•×ª, ××©×™××•×ª ×•×¡×•×“×•×ª.</p>
                <div>
                    <h3 class="font-semibold text-pink-200 text-lg">××”×œ×š ×”×ª×•×¨:</h3>
                    <p>×‘×›×œ ×ª×•×¨, ×¢×•××“×ª ×‘×¤× ×™×š <strong>×¤×¢×•×œ×” ××—×ª</strong>: ×œ××©×•×š ×§×œ×£ ××”×§×•×¤×”, ××• ×œ×©×—×§ ×§×œ×£ ××”×™×“ ×©×œ×š ×œ××¨×›×– ×”×©×•×œ×—×Ÿ.</p>
                </div>
                <div>
                    <h3 class="font-semibold text-pink-200 text-lg">×¡×•×’×™ ×”×§×œ×¤×™×:</h3>
                    <ul class="list-disc list-inside space-y-2 mt-2">
                        <li><strong class="text-blue-300">×©××œ×”:</strong> ×§×œ×¤×™× ×›×—×•×œ×™×. ×¢× ×• ×¢×œ ×”×©××œ×” ×™×—×“ ××• ×©×ª×¤×• ××ª ××—×©×‘×•×ª×™×›×.</li>
                        <li><strong class="text-pink-300">××©×™××”:</strong> ×§×œ×¤×™× ×•×¨×•×“×™×. ×‘×¦×¢×• ××ª ×”××©×™××” ×©×¢×œ ×”×§×œ×£ ×¢×‘×•×¨ ×”×¤×¨×˜× ×¨ ×©×œ×›×.</li>
                        <li><strong class="text-purple-300">×¡×•×“:</strong> ×§×œ×¤×™× ×¡×’×•×œ×™×. ×–×•×”×™ ××©×™××” ×¡×•×“×™×ª ×©×¢×œ×™×›× ×œ×‘×¦×¢ ××‘×œ×™ ×©×”×¤×¨×˜× ×¨ ×™×©×™× ×œ×‘.</li>
                    </ul>
                </div>
                <p class="font-bold text-yellow-300 p-3 bg-gray-700/50 rounded-lg">
                    <strong class="text-purple-300">â­ ×›×œ×œ ××™×•×—×“ ×œ×§×œ×£ ×¡×•×“:</strong>
                    ×›×©××ª/×” ××©×—×§/×ª ×§×œ×£ <strong>×¡×•×“</strong>, ×ª×•×¨×š ×œ× ××¡×ª×™×™×! ××ª/×” ××§×‘×œ/×ª <strong>×¤×¢×•×œ×” × ×•×¡×¤×ª</strong> ×‘××•×ª×• ×”×ª×•×¨.
                </p>
                <p class="font-bold text-green-300 p-3 bg-gray-700/50 rounded-lg">
                    <strong>ğŸ ××™×š ×× ×¦×—×™×?</strong><br />
                    ×œ× ×× ×¦×—×™×! ×”×™× ×ª××™×“ ×¦×•×“×§×ª ×•×”×× ×¦×—×ª!
                </p>
            </div>
            <button id="close-rules-btn" class="absolute top-4 left-4 text-gray-400 hover:text-white text-2xl">&times;</button>
        </div>
    </div>

    <div id="home-screen" class="w-full h-full flex flex-col items-center justify-center text-center">
        <h1 class="text-4xl sm:text-5xl font-bold text-pink-300 mb-4">×—×•×‘×” ×•×—×•×‘×” - ×’×¨×¡×ª ×”×–×•×’×•×ª</h1>
        <p class="text-gray-300 mb-6 max-w-md px-4">×¦×¨×• ×—×“×¨ ×¤×¨×˜×™ ×•×©×ª×¤×• ××ª ×”×§×•×“ ×¢× ×”×¤×¨×˜× ×¨ ×›×“×™ ×œ×”×ª×—×™×œ ×œ×©×—×§.</p>
        <div class="bg-gray-800/50 p-6 rounded-lg shadow-lg w-full max-w-sm">
            <p id="auth-status" class="text-yellow-400 mb-4 text-sm">××ª×—×‘×¨...</p>
            <input id="player-name-input" type="text" placeholder="×”×›× ×™×¡×• ××ª ×©××›×" class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white w-full mb-3 text-center text-lg">
            <input id="room-id-input" type="text" placeholder="×”×›× ×™×¡×• ×§×•×“ ×—×“×¨" class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white w-full mb-3 text-center text-lg">
            <button id="join-room-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg w-full mb-3 disabled:opacity-50 disabled:cursor-not-allowed" disabled>×”×¦×˜×¨×£ ×œ×—×“×¨</button>
            <button id="create-room-btn" class="bg-pink-600 hover:bg-pink-700 text-white font-bold py-3 px-4 rounded-lg w-full disabled:opacity-50 disabled:cursor-not-allowed" disabled>×¦×•×¨ ×—×“×¨<p style="font-size: 12px">(×œ×¢×™×ª×™× ×™×™×§×— ×¢×“ 10 ×©× ×™×•×ª)</p></button>
            <button id="rules-btn" class="mt-4 text-pink-200 bg-pink-500/10 hover:bg-pink-500/20 border border-pink-500/30 font-semibold py-2 px-6 rounded-lg w-full transition-colors">
                ××™×š ××©×—×§×™×?
            </button>
        </div>
    </div>

    <div id="ai-loading-overlay" class="hidden fixed inset-0 z-20 flex-col items-center justify-center bg-gray-900/80 backdrop-blur-sm">
        <div class="bg-gray-800/80 p-8 rounded-lg shadow-xl text-center border border-pink-500">
            <div class="loader mb-4 mx-auto"></div>
            <h2 class="text-2xl font-bold text-pink-300">×™×•×¦×¨ ×§×œ×¤×™× ×‘×¢×–×¨×ª ×‘×™× ×” ××œ××›×•×ª×™×ª...</h2>
            <p id="loading-timer" class="text-gray-400 mt-2">×–××Ÿ ×©×—×œ×£: 0×©</p>
        </div>
    </div>

    <div id="game-over-modal" class="hidden fixed inset-0 z-30 flex items-center justify-center bg-black bg-opacity-70 backdrop-blur-sm">
        <div class="bg-gray-800 p-8 rounded-lg shadow-xl text-center border border-green-500">
            <h3 class="text-3xl font-bold mb-4 text-green-300">×”××©×—×§ ×”×¡×ª×™×™×!</h3>
            <button id="go-home-after-game-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg">×—×–×•×¨ ×—×–×¨×”</button>
        </div>
    </div>

    <div id="game-container" class="hidden w-full h-full flex flex-col items-center max-w-7xl mx-auto">
        <div id="opponent-left-modal" class="hidden fixed inset-0 z-20 flex items-center justify-center bg-gray-900/80 backdrop-blur-sm">
            <div class="bg-gray-800 p-8 rounded-lg shadow-xl text-center border border-red-500">
                <h3 class="text-2xl font-bold mb-4 text-red-400">×”×¤×¨×˜× ×¨ ×”×ª× ×ª×§</h3>
                <p class="text-gray-300 mb-6">×”×¤×¨×˜× ×¨ ×¢×–×‘ ××ª ×”××©×—×§.</p>
                <button id="go-home-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg">×—×–×•×¨ ×œ××¡×š ×”×¨××©×™</button>
            </div>
        </div>

        <header class="w-full p-1 sm:p-2 flex flex-wrap justify-between items-center gap-x-2 gap-y-1 text-xs sm:text-sm flex-shrink-0">
            <div class="bg-gray-800/50 p-2 sm:p-3 rounded-lg shadow-lg text-left order-1 flex-shrink-0">
                <h2 class="text-base sm:text-lg font-bold mb-1 text-center">×©×—×§× ×™×</h2>
                <div><strong>××ª/×”:</strong> <span id="your-name" class="font-mono text-blue-300"></span></div>
                <div><strong>×¤×¨×˜× ×¨:</strong> <span id="opponent-name" class="font-mono text-red-300">×××ª×™×Ÿ...</span></div>
            </div>
            <div id="turn-indicator" class="w-full text-center text-base sm:text-xl font-bold text-yellow-300 order-3 sm:order-2 sm:w-auto flex-1 px-2"></div>
            <div class="bg-gray-800/50 p-2 sm:p-3 rounded-lg shadow-lg text-center order-2 sm:order-3 flex-shrink-0">
                <h2 class="text-base sm:text-lg font-bold mb-1">×§×•×“ ×—×“×¨</h2>
                <div id="room-id-display" class="bg-gray-700 text-pink-300 font-mono px-3 py-1 sm:px-4 sm:py-2 rounded-md text-base sm:text-xl tracking-widest"></div>
            </div>
        </header>

        <div id="opponent-hand" class="h-32 sm:h-48 w-full flex-shrink-0"></div>

        <main id="play-area" class="w-full flex-grow bg-gray-800/50 rounded-2xl border-2 border-dashed border-gray-600 flex items-center justify-center p-2 my-2 relative"></main>

        <footer id="bottom-bar" class="w-full flex justify-between items-end p-1 sm:p-2 flex-shrink-0 h-44 sm:h-48">
            <div id="player-hand" class="flex-grow h-full flex justify-center items-end">
            </div>
            <div id="deck-area" class="flex flex-col items-center flex-shrink-0 pl-2">
                <div id="deck" class="mb-2"></div>
                <div id="deck-counter" class="text-base sm:text-lg font-semibold">0 ×§×œ×¤×™×</div>
            </div>
        </footer>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, arrayUnion, deleteDoc, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDLpWqy6RzBd5VQrfK7T94FQAseXTbjJSg",
            authDomain: "hilit-a2e48.firebaseapp.com",
            projectId: "hilit-a2e48",
            storageBucket: "hilit-a2e48.appspot.com",
            messagingSenderId: "337097539085",
            appId: "1:337097539085:web:e8b516719a14d14eec5f44"
        };

        let app, auth, db, userId, gameUnsubscribe = null, currentRoomId = null, gameHasStartedWithTwoPlayers = false, heartbeatInterval = null, loadingTimerInterval = null, toastTimeout = null;

        const CARD_TYPES = { QUESTION: '×©××œ×”', ASSIGNMENT: '××©×™××”', SECRET: '×¡×•×“' };

        const elements = {
            deck: document.getElementById('deck'), deckCounter: document.getElementById('deck-counter'),
            playerHand: document.getElementById('player-hand'), opponentHand: document.getElementById('opponent-hand'),
            playArea: document.getElementById('play-area'), createRoomBtn: document.getElementById('create-room-btn'),
            joinRoomBtn: document.getElementById('join-room-btn'), roomIdInput: document.getElementById('room-id-input'),
            roomIdDisplay: document.getElementById('room-id-display'), authStatus: document.getElementById('auth-status'),
            yourNameSpan: document.getElementById('your-name'), opponentNameSpan: document.getElementById('opponent-name'),
            opponentLeftModal: document.getElementById('opponent-left-modal'), goHomeBtn: document.getElementById('go-home-btn'),
            homeScreen: document.getElementById('home-screen'), gameContainer: document.getElementById('game-container'),
            aiLoadingOverlay: document.getElementById('ai-loading-overlay'), loadingTimer: document.getElementById('loading-timer'),
            playerNameInput: document.getElementById('player-name-input'), rulesBtn: document.getElementById('rules-btn'),
            rulesModal: document.getElementById('rules-modal'), closeRulesBtn: document.getElementById('close-rules-btn'),
            turnIndicator: document.getElementById('turn-indicator'),
            toast: document.getElementById('toast-notification'),
            gameOverModal: document.getElementById('game-over-modal'),
            goHomeAfterGameBtn: document.getElementById('go-home-after-game-btn'),
        };

        const fallbackCards = [
            { text: "××”×• ×”×–×™×›×¨×•×Ÿ ×”××©×•×ª×£ ×”×¨××©×•×Ÿ ×©××ª× ×–×•×›×¨×™×?", type: CARD_TYPES.QUESTION }, { text: "××” ×”×“×‘×¨ ×©×”×›×™ ×”×¦×—×™×§ ××ª×›× ×©×¢×©×™×ª× ×™×—×“?", type: CARD_TYPES.QUESTION }, { text: "××”×• ×”×—×œ×•× ×”×›×™ ×’×“×•×œ ×©×œ×š ×›×¨×’×¢?", type: CARD_TYPES.QUESTION }, { text: "×× ×”×™×™×ª ×—×™×”, ××™×–×• ×—×™×” ×”×™×™×ª ×‘×•×—×¨/×ª ×œ×”×™×•×ª?", type: CARD_TYPES.QUESTION }, { text: "××”×• ×”×“×‘×¨ ×©××ª/×” ×”×›×™ ××¢×¨×™×š/×” ×‘×™?", type: CARD_TYPES.QUESTION },
            { text: "×¢×¡×” ××ª ×›×¤×•×ª ×”×¨×’×œ×™×™× ×©×œ ×”×¤×¨×˜× ×¨ ×œ××©×š ×“×§×”.", type: CARD_TYPES.ASSIGNMENT }, { text: "×œ×—×© 3 ×“×‘×¨×™× ×©××ª/×” ××•×”×‘/×ª ×‘×•/×‘×” ×‘××•×–×Ÿ.", type: CARD_TYPES.ASSIGNMENT }, { text: "×”×¡×ª×›×œ/×™ ×œ×‘×ª ×”×–×•×’ ×‘×¢×™× ×™×™× ×œ××©×š ×“×§×”", type: CARD_TYPES.ASSIGNMENT }, { text: "×‘×—×¨×• ×©×™×¨ ×•×¨×§×“×• ×œ×¦×œ×™×œ×™×• ×›××™×œ×• ××£ ××—×“ ×œ× ×¨×•××”.", type: CARD_TYPES.ASSIGNMENT }, { text: "×ª×Ÿ/×™ ×œ×¤×¨×˜× ×¨ × ×©×™×§×” ×‘××§×•× ×”×›×™ ×œ× ×¦×¤×•×™.", type: CARD_TYPES.ASSIGNMENT },
            { text: "×’×¢/×™ ×‘×©×™×¢×¨ ×©×œ ×”×¤×¨×˜× ×¨ ×‘×¢×“×™× ×•×ª ××‘×œ×™ ×©×™×‘×—×™×Ÿ/×ª×‘×—×™×Ÿ.", type: CARD_TYPES.SECRET }, { text: "×”×—×‘×/×”×—×‘×™××™ ×¤×ª×§ ××”×‘×” ×§×˜×Ÿ ×‘×›×™×¡ ×©×œ ×”×¤×¨×˜× ×¨.", type: CARD_TYPES.SECRET }, { text: "×©×œ×—/×™ ×”×•×“×¢×” ××ª×•×§×” ×œ×˜×œ×¤×•×Ÿ ×©×œ ×”×¤×¨×˜× ×¨.", type: CARD_TYPES.SECRET }, { text: "×”×—××/×™ ×œ×¤×¨×˜× ×¨ ×¢×œ ××©×”×• ×›×©×”×•×/×”×™× ×œ× ××¦×¤×”.", type: CARD_TYPES.SECRET }, { text: "×©×™×/×©×™××™ ××ª ×”×™×“ ×¢×œ ×”×œ×‘ ×©×œ×š ×›×©×”×¤×¨×˜× ×¨ ××¡×ª×›×œ ×¢×œ×™×š.", type: CARD_TYPES.SECRET }
        ];

        function showToast(message, type = 'info', duration = 3000) {
            if (toastTimeout) clearTimeout(toastTimeout);
            elements.toast.textContent = message;
            elements.toast.className = 'toast-info';
            elements.toast.classList.add(`toast-${type}`);
            elements.toast.classList.add('show');
            toastTimeout = setTimeout(() => {
                elements.toast.classList.remove('show');
            }, duration);
        }

        async function generateCards() {
            const prompt = `×¦×•×¨ 30 ×§×œ×¤×™× ×œ××©×—×§ ×–×•×’×™ ×‘×¢×‘×¨×™×ª, ×‘×¤×•×¨××˜ JSON. ×›×œ ××•×‘×™×™×§×˜ ×‘×§×œ×£ ×—×™×™×‘ ×œ×”×›×™×œ 'text' ×•-'type'. ×”×©×ª××© ×‘×¡×•×’×™×: "×©××œ×”", "××©×™××”", ×•"×¡×•×“". ×¦×•×¨ ×‘×¢×¨×š 10 ×§×œ×¤×™× ××›×œ ×¡×•×’. "×©××œ×”" - ×©××œ×•×ª ×©××¢×•×¨×¨×•×ª ×©×™×—×” ×¨×•×× ×˜×™×ª ××• ××¨×’×©×ª. "××©×™××”" - ××©×™××•×ª ×¨×•×× ×˜×™×•×ª ××• ×©×•×‘×‘×•×ª ×œ×‘×™×¦×•×¢ ×™×—×“. "×¡×•×“" - ××©×™××•×ª ×©×¦×¨×™×š ×œ×‘×¦×¢ ×‘×œ×™ ×©×”×©× ×™ ×™×©×™× ×œ×‘, ×“×‘×¨×™× ×©×•×‘×‘×™× ×•×¨×•×× ×˜×™×™×. ×›×œ ×˜×§×¡×˜ ×—×™×™×‘ ×œ×”×™×•×ª ×§×¦×¨, ×¢×“ 15 ××™×œ×™×.`;
            const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json", responseSchema: { type: "ARRAY", items: { type: "OBJECT", properties: { "text": { "type": "STRING" }, "type": { "type": "STRING" } }, required: ["text", "type"] } } } };
            const apiKey = "AIzaSyDPHa7RzXYbgaVY-lCFwW0JE2Mh3OptJ6Y";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
                const result = await response.json();
                const cards = JSON.parse(result.candidates[0].content.parts[0].text);
                if (!cards || cards.length === 0) throw new Error("AI returned empty cards.");
                return cards;
            } catch (error) {
                console.warn("AI card generation failed, using fallback cards.", error);
                return fallbackCards;
            }
        }

        async function createRoom() {
            const playerName = elements.playerNameInput.value.trim();
            if (!playerName) { showToast("×× × ×”×›× ×™×¡×• ××ª ×©××›×.", 'warning'); return; }
            if (!userId) return;
            elements.createRoomBtn.disabled = true; elements.joinRoomBtn.disabled = true;
            elements.aiLoadingOverlay.classList.remove('hidden'); elements.aiLoadingOverlay.classList.add('flex');
            let seconds = 0;
            loadingTimerInterval = setInterval(() => { seconds++; elements.loadingTimer.textContent = `×–××Ÿ ×©×—×œ×£: ${seconds}×©`; }, 1000);
            const cards = await generateCards();
            clearInterval(loadingTimerInterval); loadingTimerInterval = null;
            const roomId = generateRoomId();
            const gameRef = doc(db, 'games', roomId);
            const deck = shuffleDeck(cards.map((card, index) => ({ id: index + 1, ...card, instanceId: crypto.randomUUID() })));
            const gameData = {
                players: { [userId]: { name: playerName, hand: [], lastSeen: new Date() } },
                deck: deck, playArea: [], hostId: userId, createdAt: new Date(),
                turn: { currentPlayerId: userId, turnNumber: 1 },
                gameState: 'playing'
            };
            try {
                await setDoc(gameRef, gameData);
                joinRoom(roomId);
            } catch (error) {
                console.error("Error creating room: ", error);
                elements.aiLoadingOverlay.classList.add('hidden'); elements.aiLoadingOverlay.classList.remove('flex');
                elements.createRoomBtn.disabled = false; elements.joinRoomBtn.disabled = false;
            }
        }

        function initializeGame() {
            const savedName = localStorage.getItem('couplesDarePlayerName');
            if (savedName) elements.playerNameInput.value = savedName;
            elements.playerNameInput.addEventListener('keyup', () => localStorage.setItem('couplesDarePlayerName', elements.playerNameInput.value.trim()));
            createFloatingHearts();
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app); auth = getAuth(app);
                onAuthStateChanged(auth, user => {
                    if (user) {
                        userId = user.uid;
                        elements.authStatus.textContent = "××—×•×‘×¨!"; elements.authStatus.style.color = '#a7f3d0';
                        elements.createRoomBtn.disabled = false; elements.joinRoomBtn.disabled = false;
                    } else {
                        signInAnonymously(auth).catch(error => {
                            elements.authStatus.textContent = "×”×—×™×‘×•×¨ × ×›×©×œ!"; elements.authStatus.style.color = '#f87171';
                        });
                    }
                });
            } catch (error) {
                showToast("×œ× × ×™×ª×Ÿ ×œ×”×ª×—×‘×¨ ×œ×©×™×¨×•×ª ×”××©×—×§.", 'warning');
                elements.authStatus.textContent = "×©×’×™××”!"; elements.authStatus.style.color = '#f87171';
            }
        }

        async function joinRoom(roomId) {
            const playerName = elements.playerNameInput.value.trim();
            if (!playerName) { showToast("×× × ×”×›× ×™×¡×• ××ª ×©××›× ×œ×¤× ×™ ×”×¦×˜×¨×¤×•×ª.", 'warning'); return; }
            if (!userId || !roomId) return;
            const gameRef = doc(db, 'games', roomId);
            const gameSnap = await getDoc(gameRef);
            if (gameSnap.exists()) {
                const gameData = gameSnap.data();
                if (Object.keys(gameData.players).length >= 2 && !gameData.players[userId]) {
                    showToast("×”×—×“×¨ ××œ×.", 'warning'); return;
                }
                if (!gameData.players[userId]) {
                    await updateDoc(gameRef, { [`players.${userId}`]: { name: playerName, hand: [], lastSeen: new Date() } });
                }
                currentRoomId = roomId;
                subscribeToGameUpdates(roomId); startHeartbeat();
                elements.roomIdDisplay.textContent = roomId;
                elements.homeScreen.classList.add('hidden');
                elements.aiLoadingOverlay.classList.add('hidden'); elements.aiLoadingOverlay.classList.remove('flex');
                elements.gameContainer.classList.remove('hidden');
                elements.gameContainer.classList.add('flex');
            } else {
                showToast("×”×—×“×¨ ×œ× × ××¦×!", 'warning');
            }
        }

        async function leaveRoom() {
            stopHeartbeat();
            if (!currentRoomId || !userId) return;
            const gameRef = doc(db, 'games', currentRoomId);
            const gameSnap = await getDoc(gameRef);
            if (gameSnap.exists()) {
                const playerCount = Object.keys(gameSnap.data().players).length;
                if (playerCount <= 1) await deleteDoc(gameRef);
                else await updateDoc(gameRef, { [`players.${userId}`]: deleteField() });
            }
            currentRoomId = null;
        }

        function subscribeToGameUpdates(roomId) {
            if (gameUnsubscribe) gameUnsubscribe();
            const gameRef = doc(db, 'games', roomId);
            gameUnsubscribe = onSnapshot(gameRef, (doc) => {
                if (!doc.exists()) {
                    if (!elements.opponentLeftModal.classList.contains('hidden')) return;
                    showToast("×—×“×¨ ×”××©×—×§ × ×¡×’×¨.", 'info');
                    setTimeout(() => window.location.reload(), 2000); return;
                }
                renderGameState(doc.data());
            });
        }

        async function endTurn() {
            if (!currentRoomId) return;
            const gameRef = doc(db, 'games', currentRoomId);
            const gameSnap = await getDoc(gameRef);
            if (gameSnap.exists()) {
                const gameData = gameSnap.data();
                if (gameData.gameState === 'finished') return;

                const playerIds = Object.keys(gameData.players);
                const opponentId = playerIds.find(id => id !== userId);
                let nextPlayerId = opponentId;

                if (gameData.deck.length === 0 && playerIds.length === 2) {
                    const myHand = gameData.players[userId].hand;
                    const opponentHand = gameData.players[opponentId].hand;
                    if (myHand.length === 0 && opponentHand.length > 0) {
                        nextPlayerId = opponentId;
                    } else if (opponentHand.length === 0 && myHand.length > 0) {
                        nextPlayerId = userId;
                    }
                }

                await updateDoc(gameRef, { 'turn.currentPlayerId': nextPlayerId, 'turn.turnNumber': gameData.turn.turnNumber + 1 });
            }
        }

        function renderOpponentHandAsArc(hand) {
            elements.opponentHand.innerHTML = '';
            const cardCount = hand.length;
            if (cardCount === 0) return;
            const totalArcAngle = Math.min(cardCount * 10, 80);
            hand.forEach((cardData, index) => {
                const cardElement = createCardElement(cardData, true);
                const rotation = (index - (cardCount - 1) / 2) * (totalArcAngle / cardCount);
                cardElement.style.transform = `translateX(-50%) rotate(${rotation}deg)`;
                elements.opponentHand.appendChild(cardElement);
            });
        }

        function renderGameState(gameData) {
            if (gameData.gameState === 'finished') {
                elements.gameContainer.style.filter = 'blur(5px)';
                elements.gameOverModal.classList.remove('hidden');
                return;
            }

            const playerIds = Object.keys(gameData.players);
            const opponentId = playerIds.find(id => id !== userId);

            if (opponentId) {
                const opponentData = gameData.players[opponentId];
                if (opponentData.lastSeen) {
                    const secondsSinceLastSeen = (new Date().getTime() - opponentData.lastSeen.toDate().getTime()) / 1000;
                    if (secondsSinceLastSeen > 15) { removeOpponent(opponentId); return; }
                }
            }
            if (playerIds.length === 2) gameHasStartedWithTwoPlayers = true;
            if (gameHasStartedWithTwoPlayers && playerIds.length < 2 && playerIds.includes(userId)) {
                elements.opponentLeftModal.classList.remove('hidden'); elements.opponentLeftModal.classList.add('flex');
                return;
            }

            elements.playerHand.innerHTML = '';
            elements.playArea.innerHTML = '';

            const playerState = gameData.players[userId];
            const opponentState = opponentId ? gameData.players[opponentId] : null;

            if (playerState) elements.yourNameSpan.textContent = playerState.name;
            elements.opponentNameSpan.textContent = opponentState ? opponentState.name : '×××ª×™×Ÿ...';

            if (gameData.turn && opponentState) {
                if (gameData.turn.currentPlayerId === userId) {
                    elements.turnIndicator.textContent = "×”×ª×•×¨ ×©×œ×š!";
                    document.body.classList.add('is-my-turn');
                } else {
                    elements.turnIndicator.textContent = `×”×ª×•×¨ ×©×œ ${opponentState.name}...`;
                    document.body.classList.remove('is-my-turn');
                }
            } else {
                elements.turnIndicator.textContent = "×××ª×™× ×™× ×œ×©×—×§×Ÿ × ×•×¡×£...";
            }

            // DYNAMIC HAND RENDERING LOGIC
            if (playerState && playerState.hand.length > 0) {
                const handCount = playerState.hand.length;
                const containerWidth = elements.playerHand.offsetWidth;

                const cardMinWidth = 80;
                const cardMaxWidth = 120;
                const cardWidthVW = 22;
                const calculatedVWwidth = (window.innerWidth * cardWidthVW) / 100;
                const cardWidth = Math.max(cardMinWidth, Math.min(calculatedVWwidth, cardMaxWidth));

                const defaultMargin = 8;
                let marginLeft = `${defaultMargin}px`;

                const totalCardsWidth = (handCount * cardWidth) + ((handCount - 1) * defaultMargin);

                if (totalCardsWidth > containerWidth) {
                    const newMargin = (containerWidth - (handCount * cardWidth)) / (handCount - 1);
                    const minMargin = - (cardWidth * 0.75); // Overlap up to 75% of the card
                    marginLeft = `${Math.max(newMargin, minMargin)}px`;
                }

                playerState.hand.forEach((cardData, index) => {
                    const cardElement = createCardElement(cardData, false);
                    cardElement.addEventListener('click', () => playCard(cardData.instanceId));
                    if (index > 0) {
                        cardElement.style.marginLeft = marginLeft;
                    }
                    elements.playerHand.appendChild(cardElement);
                });
            }


            if (opponentState) {
                renderOpponentHandAsArc(opponentState.hand);
            } else {
                elements.opponentHand.innerHTML = '';
            }

            gameData.playArea.forEach(cardData => {
                const cardElement = createCardElement(cardData, false);
                const randomRotation = (Math.random() - 0.5) * 15;
                cardElement.style.transform = `rotate(${randomRotation}deg)`;
                elements.playArea.appendChild(cardElement);
            });
            renderDeck(gameData.deck.length, playerIds.length);
        }

        async function drawCard() {
            if (!currentRoomId) return;
            const gameRef = doc(db, 'games', currentRoomId);
            const gameSnap = await getDoc(gameRef);
            if (gameSnap.exists()) {
                const gameData = gameSnap.data();
                if (Object.keys(gameData.players).length < 2) {
                    showToast("×™×© ×œ×”××ª×™×Ÿ ×œ×©×—×§×Ÿ × ×•×¡×£...", 'info');
                    return;
                }
                if (gameData.turn.currentPlayerId !== userId) { showToast("×–×” ×œ× ×”×ª×•×¨ ×©×œ×š!", 'warning'); return; }
                if (gameData.deck.length > 0) {
                    const playerHand = gameData.players[userId].hand;
                    if (playerHand.length >= 5) { showToast("×”×™×“ ×©×œ×š ××œ××”! (×¢×“ 5 ×§×œ×¤×™×)", 'warning'); return; }
                    const newDeck = [...gameData.deck];
                    const drawnCard = newDeck.pop();
                    playerHand.push(drawnCard);
                    await updateDoc(gameRef, { deck: newDeck, [`players.${userId}.hand`]: playerHand });
                    await endTurn();
                } else {
                    showToast("×”×§×•×¤×” ×¨×™×§×”!", 'info');
                }
            }
        }

        async function playCard(cardInstanceId) {
            if (!currentRoomId) return;
            const gameRef = doc(db, 'games', currentRoomId);
            const gameSnap = await getDoc(gameRef);
            if (gameSnap.exists()) {
                const gameData = gameSnap.data();
                if (Object.keys(gameData.players).length < 2) {
                    showToast("×™×© ×œ×”××ª×™×Ÿ ×œ×©×—×§×Ÿ × ×•×¡×£...", 'info');
                    return;
                }
                if (gameData.turn.currentPlayerId !== userId) { showToast("×–×” ×œ× ×”×ª×•×¨ ×©×œ×š!", 'warning'); return; }
                const playerHand = gameData.players[userId].hand;
                const cardToPlay = playerHand.find(c => c.instanceId === cardInstanceId);
                if (cardToPlay) {
                    const newHand = playerHand.filter(c => c.instanceId !== cardInstanceId);
                    const opponentId = Object.keys(gameData.players).find(id => id !== userId);
                    const opponentHand = opponentId ? gameData.players[opponentId].hand : [];

                    let updates = {
                        [`players.${userId}.hand`]: newHand,
                        playArea: arrayUnion(cardToPlay)
                    };

                    if (newHand.length === 0 && gameData.deck.length === 0 && opponentHand.length === 0) {
                        updates.gameState = 'finished';
                    }

                    await updateDoc(gameRef, updates);

                    if (updates.gameState !== 'finished') {
                        if (cardToPlay.type !== CARD_TYPES.SECRET) {
                            await endTurn();
                        } else {
                            showToast("×©×™×—×§×ª ×§×œ×£ ×¡×•×“! ×§×—/×™ ×¤×¢×•×œ×” × ×•×¡×¤×ª.", 'success');
                        }
                    }
                }
            }
        }

        function startHeartbeat() {
            stopHeartbeat();
            heartbeatInterval = setInterval(() => {
                if (currentRoomId && userId) {
                    const gameRef = doc(db, 'games', currentRoomId);
                    updateDoc(gameRef, { [`players.${userId}.lastSeen`]: new Date() }).catch(err => { });
                }
            }, 5000);
        }

        function stopHeartbeat() { if (heartbeatInterval) clearInterval(heartbeatInterval); heartbeatInterval = null; }

        async function removeOpponent(opponentId) {
            if (!currentRoomId) return;
            const gameRef = doc(db, 'games', currentRoomId);
            await updateDoc(gameRef, { [`players.${opponentId}`]: deleteField() });
        }

        function createCardElement(cardData, isHidden) {
            const card = document.createElement('div');
            card.className = `card ${isHidden ? '' : 'is-flipped'}`;
            if (cardData.instanceId) card.dataset.cardInstanceId = cardData.instanceId;
            const cardTypeClass = cardData.type ? `card-type-${cardData.type}` : '';
            card.innerHTML = `<div class="card-inner"><div class="card-face card-front ${cardTypeClass}">${cardData.type ? `<div class="card-type-header">${cardData.type}</div>` : ''}<p>${cardData.text}</p></div><div class="card-face card-back"></div></div>`;
            return card;
        }

        function renderDeck(count, playerCount) {
            elements.deck.innerHTML = '';
            elements.deckCounter.textContent = `${count} ×§×œ×¤×™×`;
            if (count > 0) {
                for (let i = 0; i < Math.min(count, 4); i++) {
                    const cardBack = createCardElement({ text: '' }, true);
                    elements.deck.appendChild(cardBack);
                }
                if (playerCount >= 2) {
                    elements.deck.onclick = drawCard;
                } else {
                    elements.deck.onclick = () => showToast("×™×© ×œ×”××ª×™×Ÿ ×œ×©×—×§×Ÿ × ×•×¡×£...", 'info');
                }
            } else {
                elements.deck.onclick = null;
                elements.deckCounter.textContent = '×§×•×¤×” ×¨×™×§×”';
            }
        }

        function generateRoomId() { return Math.random().toString(36).substring(2, 8).toUpperCase(); }

        function shuffleDeck(array) {
            for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[array[i], array[j]] = [array[j], array[i]]; }
            return array;
        }

        function createFloatingHearts() {
            const container = document.getElementById('hearts-container');
            for (let i = 0; i < 20; i++) {
                const heart = document.createElement('div'); heart.classList.add('heart'); heart.innerHTML = 'â™¥';
                heart.style.left = `${Math.random() * 100}vw`; heart.style.animationDuration = `${Math.random() * 5 + 5}s`;
                heart.style.animationDelay = `${Math.random() * 5}s`; heart.style.fontSize = `${Math.random() * 1.5 + 0.5}rem`;
                container.appendChild(heart);
            }
        }

        elements.createRoomBtn.addEventListener('click', createRoom);
        elements.joinRoomBtn.addEventListener('click', () => {
            const roomId = elements.roomIdInput.value.trim().toUpperCase();
            if (roomId) joinRoom(roomId);
        });
        elements.goHomeBtn.addEventListener('click', () => { stopHeartbeat(); window.location.reload(); });
        elements.goHomeAfterGameBtn.addEventListener('click', () => { window.location.reload(); });
        elements.rulesBtn.addEventListener('click', () => elements.rulesModal.classList.remove('hidden'));
        elements.closeRulesBtn.addEventListener('click', () => elements.rulesModal.classList.add('hidden'));

        window.addEventListener('beforeunload', leaveRoom);
        window.onload = initializeGame;

    </script>
</body>
</html>
